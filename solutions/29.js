/*
Consider all integer combinations of ab for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:

22=4, 23=8, 24=16, 25=32
32=9, 33=27, 34=81, 35=243
42=16, 43=64, 44=256, 45=1024
52=25, 53=125, 54=625, 55=3125
If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:

4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

How many distinct terms are in the sequence generated by ab for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
*/

// There's a way to optimize this that I haven't yet figured out
// Since 4 ^ 2 is 2 ^ 4, and 9 ^ 3 is 3 ^ 9 etc.
// Similarly, 25 ^ 2 is 5 ^ 4, and 9 ^ 4 is 3 ^ 8
// So if a or b or both are already exponents, you can decompose them
// However, as you reach the ceiling, you need to start computing again
// (e.g. we still need to calculate 64 ^ 64 even though it's a power of 2)

// I had to implement a safe way to do big exponents because otherwise
// We go over Number.MAX_BIG_INT and get the wrong answer
// My implementation of bigExponent is a bit slow but still usable
const intArray = require('../helpers/intArray')
const bigExponent = require('../helpers/bigExponent')
/**
 * Count distinct terms in the sequence generated by a^b for
 * a, b in range (floor, ceil)
 * @param {number} [ceil] - ceiling of range (inclusive)
 * @param {number} [floor] - floor of range (inclusive)
 * @returns {number}
 */
function distinctTerms(ceil = 100, floor = 2) {
  return new Set(
    intArray(ceil, floor).reduce(
      (arr, a, _, B) => arr.concat(B.map(b => bigExponent(a, b, true))),
      []
    )
  ).size
}

console.time('s')
console.log(distinctTerms())
console.timeEnd('s')